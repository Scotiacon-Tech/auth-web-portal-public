var u=Object.defineProperty;var l=(n,e,t)=>e in n?u(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var a=(n,e,t)=>l(n,typeof e!="symbol"?e+"":e,t);import{a as p,O as g}from"./Bir1xsaG.js";function S(n){return{all:n=n||new Map,on:function(e,t){var i=n.get(e);i?i.push(t):n.set(e,[t])},off:function(e,t){var i=n.get(e);i&&(t?i.splice(i.indexOf(t)>>>0,1):n.set(e,[]))},emit:function(e,t){var i=n.get(e);i&&i.slice().map(function(s){s(t)}),(i=n.get("*"))&&i.slice().map(function(s){s(e,t)})}}}const c=class c{static getInstance(){return c.instance}};a(c,"instance",S());let h=c;const r=class r{constructor(e=[],t=h.getInstance()){a(this,"emitter");a(this,"tokens",[]);if(this.tokens=e,this.emitter=t,e.length===0){const i=localStorage.getItem("managedTokens");if(i!=null&&i!=="")try{this.tokens=JSON.parse(i),this.tokens.forEach(s=>{const o=JSON.stringify(s.OAuthToken),T=new p;T.parseJSON(o),s.OAuthToken=T;const d=JSON.stringify(s.OAuthConfig),m=new g;m.parseJSON(d),s.OAuthConfig=m})}catch(s){console.error(s)}}this.init()}init(){localStorage.setItem("managedTokens",JSON.stringify(this.tokens)),this.tokens.forEach(e=>{this.startTimer(e,1)})}static getInstance(e=[],t=void 0){return r.instance===void 0?r.instance=new r(e,t):(e.length>0&&(r.instance.tokens.forEach(i=>{i.Timer!==null&&clearTimeout(i.Timer)}),r.instance.tokens=e,r.instance.init()),t&&(r.instance.emitter=t)),r.instance}emitSessionExpired(e){this.emitter.emit("tokenManager.sessionExpired",e)}addToken(e){this.tokens.filter((i,s)=>i.Service===e.Service).forEach(i=>{i.Timer!==null&&clearTimeout(i.Timer)}),this.tokens=this.tokens.filter((i,s)=>i.Service!==e.Service),this.startTimer(e,1),this.tokens.push(e),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}getTokenByService(e){return this.tokens.find(t=>t.Service===e)}getTokenStringByService(e){var t;return(t=this.getTokenByService(e))==null?void 0:t.OAuthToken}removeTokensByService(e){this.tokens.forEach(t=>{t.Service===e&&(this.removeToken(t),this.emitSessionExpired(t))}),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}parseTokenResponse(e,t){e.OAuthToken.AccessToken=t.access_token,e.OAuthToken.RefreshToken=t.refresh_token,e.OAuthToken.TokenType=t.token_type,e.OAuthToken.ExpiresIn=t.expires_in,this.tokenUpdated(e)}async refreshToken(e){let t;const i=new Headers;if(i.append("Content-Type","application/json"),e.Method.toLowerCase()==="header"){const s=e.OAuthToken.RefreshToken||e.OAuthToken.AccessToken;e.Header.toLowerCase()==="Authorization".toLowerCase()?i.append("Authorization",`Bearer ${s}`):i.append(e.Header,s)}else if(e.Header){const s={};s[e.Header]=e.OAuthToken.RefreshToken||e.OAuthToken.AccessToken,t=s}try{const s=await fetch(`${e.Endpoint}`,{method:e.Method.toUpperCase()==="POST"?"POST":"GET",headers:i,redirect:"follow",...t});if(s.status===401)return this.removeToken(e),this.emitSessionExpired(e),!1;if(s.status!==200)return await this.retryTokenRefresh(e);s.json().then(o=>{this.parseTokenResponse(e,o)})}catch{return await this.retryTokenRefresh(e)}return!0}retryTokenRefresh(e){return new Promise((t,i)=>{this.accessTimeRemaining(e)>0?e.Timer||(e.Timer=setTimeout(()=>{e.Timer=void 0,this.refreshToken(e).then(o=>o?t(o):i(o)).catch(()=>{i(!1)})},1e4)):(this.removeToken(e),this.emitSessionExpired(e))})}startTimer(e,t=0){let i=this.accessTimeRemaining(e);if(i<0){this.removeToken(e),this.emitSessionExpired(e);return}i-1e3*600<0&&(i=20),e.Timer||(e.Timer=setTimeout(()=>{e.Timer=void 0,this.refreshToken(e).then(()=>{}).catch(()=>{})},t||i-10))}accessTimeRemaining(e){const t=new Date;return new Date(e.Expires-t.getTime()).getTime()}removeToken(e){e.Timer!==null&&clearTimeout(e.Timer);const t=this.tokens.findIndex(i=>i===e);t>=0&&this.tokens.splice(t,1),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}tokenUpdated(e){this.startTimer(e),localStorage.setItem("managedTokens",JSON.stringify(this.tokens)),this.emitter.emit("tokenManager.tokenUpdated",e)}};a(r,"instance");let f=r;export{f as T};
