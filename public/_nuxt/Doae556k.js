var l=Object.defineProperty;var p=(n,e,i)=>e in n?l(n,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[e]=i;var o=(n,e,i)=>p(n,typeof e!="symbol"?e+"":e,i);import{a as u,O as g}from"./BtRdvlQN.js";function S(n){return{all:n=n||new Map,on:function(e,i){var t=n.get(e);t?t.push(i):n.set(e,[i])},off:function(e,i){var t=n.get(e);t&&(i?t.splice(t.indexOf(i)>>>0,1):n.set(e,[]))},emit:function(e,i){var t=n.get(e);t&&t.slice().map(function(s){s(i)}),(t=n.get("*"))&&t.slice().map(function(s){s(e,i)})}}}const a=class a{static getInstance(){return a.instance}};o(a,"instance",S());let h=a;const r=class r{constructor(e=[],i=h.getInstance()){o(this,"emitter");o(this,"tokens",[]);if(this.tokens=e,this.emitter=i,e.length===0){const t=localStorage.getItem("managedTokens");if(t!=null&&t!=="")try{this.tokens=JSON.parse(t),this.tokens.forEach(s=>{const c=JSON.stringify(s.OAuthToken),T=new u;T.parseJSON(c),s.OAuthToken=T;const d=JSON.stringify(s.OAuthConfig),m=new g;m.parseJSON(d),s.OAuthConfig=m})}catch(s){console.error(s)}}this.init()}init(){localStorage.setItem("managedTokens",JSON.stringify(this.tokens)),this.tokens.forEach(e=>{this.startTimer(e,1)})}static getInstance(e=[],i=void 0){return r.instance===void 0?r.instance=new r(e,i):(e.length>0&&(r.instance.tokens.forEach(t=>{t.Timer!==null&&clearTimeout(t.Timer)}),r.instance.tokens=e,r.instance.init()),i&&(r.instance.emitter=i)),r.instance}emitSessionExpired(e){this.emitter.emit("tokenManager.sessionExpired",e)}addToken(e){this.tokens.filter((t,s)=>t.Service===e.Service).forEach(t=>{t.Timer!==null&&clearTimeout(t.Timer)}),this.tokens=this.tokens.filter((t,s)=>t.Service!==e.Service),this.startTimer(e,1),this.tokens.push(e),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}getTokenByService(e){return this.tokens.find(i=>i.Service===e)}getTokenStringByService(e){var i;return(i=this.getTokenByService(e))==null?void 0:i.OAuthToken}removeTokensByService(e){this.tokens.forEach(i=>{i.Service===e&&(this.removeToken(i),this.emitSessionExpired(i))}),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}parseTokenResponse(e,i){e.OAuthToken.AccessToken=i.access_token,e.OAuthToken.RefreshToken=i.refresh_token,e.OAuthToken.TokenType=i.token_type,e.OAuthToken.ExpiresIn=i.expires_in,this.tokenUpdated(e)}refreshToken(e){let i;const t=new Headers;if(t.append("Content-Type","application/json"),e.Method.toLowerCase()==="header"){const s=e.OAuthToken.RefreshToken||e.OAuthToken.AccessToken;e.Header.toLowerCase()==="Authorization".toLowerCase()?t.append("Authorization",`Bearer ${s}`):t.append(e.Header,s)}else if(e.Header){const s={};s[e.Header]=e.OAuthToken.RefreshToken||e.OAuthToken.AccessToken,i=s}fetch(`${e.Endpoint}`,{method:e.Method.toUpperCase()==="POST"?"POST":"GET",headers:t,redirect:"follow",...i}).then(s=>{if(s.status===401){this.removeToken(e),this.emitSessionExpired(e);return}else if(s.status!==200){this.retryTokenRefresh(e);return}s.json().then(c=>{this.parseTokenResponse(e,c)})}).catch(s=>{this.retryTokenRefresh(e)})}retryTokenRefresh(e){this.accessTimeRemaining(e)>0?e.Timer||(e.Timer=setTimeout(()=>{e.Timer=void 0,this.startTimer(e)},1e4)):(this.removeToken(e),this.emitSessionExpired(e))}startTimer(e,i=0){let t=this.accessTimeRemaining(e);if(t<0){this.removeToken(e),this.emitSessionExpired(e);return}t-1e3*600<0&&(t=1),e.Timer||(e.Timer=setTimeout(()=>{e.Timer=void 0,this.refreshToken(e)},i||t-10))}accessTimeRemaining(e){const i=new Date;return new Date(e.Expires-i.getTime()).getTime()}removeToken(e){e.Timer!==null&&clearTimeout(e.Timer);const i=this.tokens.findIndex(t=>t===e);i>=0&&this.tokens.splice(i,1),localStorage.setItem("managedTokens",JSON.stringify(this.tokens))}tokenUpdated(e){this.startTimer(e),localStorage.setItem("managedTokens",JSON.stringify(this.tokens)),this.emitter.emit("tokenManager.tokenUpdated",e)}};o(r,"instance");let f=r;export{f as T};
